Given an integer array nums and an integer k, modify the array in the following way:
choose an index i and replace nums[i] with -nums[i].
You should apply this process exactly k times. You may choose the same index i multiple times.
Return the largest possible sum of the array after modifying it in this way.

Example 1:
Input: nums = [4,2,3], k = 1
Output: 5
Explanation: Choose index 1 and nums becomes [4,-2,3].

Example 2:
Input: nums = [3,-1,0,2], k = 3
Output: 6
Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].

Example 3:
Input: nums = [2,-3,-1,5,-4], k = 2
Output: 13
Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].
----------------------------------------------------------------------------------------------------------------------------
// tc=O(nlogn)+O(k*nlogn)=> O(k*nlogn)  sc=O(1)
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        int n=nums.size();
        sort(nums.begin(), nums.end());
        int i=0;
        while(k>0){
            nums[i]=-nums[i];
            sort(nums.begin(),nums.end());
            k--;            
        }
        int sum=0;
        for(int j=0;j<n;j++){
            sum=sum+nums[j];
        }
        return sum;
      }
};
---------------------------------------------------------------------------------------------
// tc=O(nlogn)+O(n) =>O(nlogn) sc=O(1)
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
           sort(nums.begin(), nums.end());
        int n=nums.size();
        int i=0;
        while(i<n && nums[i]<0 && k>0){
            nums[i]=-nums[i];
            k--;
            i++;
        }
        int mn=INT_MAX;
        for(int i=0;i<n;i++){
            mn=min(mn,nums[i]);
        }

        if(k%2==1){
            mn=-mn;
        }
        int sum=0;
        for(int i=0;i<n;i++){
            sum=sum+nums[i];
        }
        if(k%2==1)
            sum-=2*abs(mn);
        return sum;

    }
};
