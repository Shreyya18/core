You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.
Return the size of the largest island in grid after applying this operation.
An island is a 4-directionally connected group of 1s.

Example 1:
Input: grid = [[1,0],[0,1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.

Example 2:
Input: grid = [[1,1],[1,0]]
Output: 4
Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.

Example 3:
Input: grid = [[1,1],[1,1]]
Output: 4
Explanation: Can't change any 0 to 1, only one island with area = 4.
-----------------------------------------------------------------------------------------------------------------------------------
//tc=O(n^2) sc=O(n^2)
class DisjointSets{
    public:
        vector<int>size,parent;
        DisjointSets(int n){
            size.resize(n+1);
            parent.resize(n+1);

            for(int i=0;i<=n;i++){
                parent[i]=i;
                size[i]=1;
            }
        }

        int findUPar(int node){
            if(node==parent[node])
                return node;
            return parent[node]=findUPar(parent[node]);
        }


        void unionBySize(int u, int v){
            int ulp_u=findUPar(u);
            int ulp_v=findUPar(v);
            if(ulp_u==ulp_v)    return;
            if(size[ulp_u]<size[ulp_v]){
                parent[ulp_u]=ulp_v;
                size[ulp_v]+=size[ulp_u];
            }
            else{
                parent[ulp_v]=ulp_u;
                size[ulp_u]+=size[ulp_v];

            }
        }
};
class Solution {
public:
    bool isValid(int row,int col, int n){
        return (row>=0 && row<n && col>=0 && col<n);
    }
    int largestIsland(vector<vector<int>>& grid) {
        int maxSize=INT_MIN;
        int n=grid.size();
        DisjointSets ds(n*n);
        for(int row=0;row<n;row++){
            for(int col=0;col<n;col++){
                if(grid[row][col]==0) continue;

                int delRow[]={-1,0,1,0};
                int delCol[]={0,1,0,-1};
                for(int i=0;i<4;i++){
                    int nRow=delRow[i]+row;
                    int nCol=delCol[i]+col;
                    if(isValid(nRow,nCol,n) && grid[nRow][nCol]==1){
                        int node1=row*n+col;
                        int node2=nRow*n+nCol;
                        ds.unionBySize(node1,node2);
                    }
                }
                
            }
        }

        for(int row=0;row<n;row++){
            for(int col=0;col<n;col++){
                if(grid[row][col]==1) continue;

                set<int>components;
                int delRow[]={-1,0,1,0};
                int delCol[]={0,1,0,-1};
                for(int i=0;i<4;i++){
                    int nRow=delRow[i]+row;
                    int nCol=delCol[i]+col;
                    if(isValid(nRow,nCol,n) && grid[nRow][nCol]==1){
                        int node=nRow*n+nCol;
                        components.insert(ds.findUPar(node));
                    }
                }
                int sizeTotal=0;
                for(auto it:components){
                    sizeTotal+= ds.size[it];

                }
                maxSize=max(maxSize,sizeTotal+1);
            }
        }

        for(int i=0;i<n*n;i++){
            maxSize=max(maxSize, ds.size[ds.findUPar(i)]);
        }

        return maxSize;

    }
};
