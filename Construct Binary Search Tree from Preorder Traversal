Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.
It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.
A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, 
and any descendant of Node.right has a value strictly greater than Node.val.
A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.

Example 1:
Input: preorder = [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]

Example 2:
Input: preorder = [1,3]
Output: [1,null,3]
----------------------------------------------------------------------------------------------------------
//tc=O(n^2) sc=O(n)

class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        int n=preorder.size();
        if(n==0)
            return NULL;
        TreeNode* node=new TreeNode(preorder[0]);
        for(int i=1;i<n;i++){
            TreeNode* root=node;
            while(root){
                if(preorder[i]<root->val){
                    if(root->left!=NULL)
                        root=root->left;
                    else{
                        root->left=new TreeNode(preorder[i]);
                        break;
                    }
                }
                else{
                    if(root->right!=NULL)
                        root=root->right;
                    else{
                        root->right=new TreeNode(preorder[i]);
                        break;
                    }
                }
            }
        }
        return node;
    }
};
------------------------------------------------------------------------------------------------------
//tc=O(n) sc=O(1)
class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        int i=0;
        return buildBST(preorder,i,INT_MAX);
    }

    TreeNode* buildBST(vector<int>& preorder, int& i, int bound ){
        if(i==preorder.size() || preorder[i]>bound)
            return NULL;
        TreeNode* root=new TreeNode(preorder[i++]);
        root->left=buildBST(preorder, i,root->val);
        root->right=buildBST(preorder, i, bound);
        return root;
    }
};

