Given a weighted, undirected, and connected graph with V vertices and E edges, your task is to find the sum of the weights of the edges 
in the Minimum Spanning Tree (MST) of the graph. The graph is provided as a list of edges, where each edge is represented as [u, v, w], indicating 
an edge between vertex u and vertex v with edge weight w.

Example 1:
Input: V = 3, E = 3, Edges = [[0, 1, 5], [1, 2, 3], [0, 2, 1]]
Output: 4
Explanation:
The Spanning Tree resulting in a weight
of 4 is shown above.

Example 2:
Input: V = 2, E = 1, Edges = [[0 1 5]]
Output: 5 
Explanation: Only one Spanning Tree is possible which has a weight of 5
-----------------------------------------------------------------------------------------------------------------------------------------------
// tc=O(E log E)+O(E log E)=> O(E log E) sc=O(E)
class Solution {
  public:
    int spanningTree(int V, vector<vector<int>>& edges) {
        // code here
        vector<vector<pair<int,int>>>adjList(V);
        
        for(auto it:edges){
            int u=it[0];
            int v=it[1];
            int w=it[2];
            
            adjList[u].push_back({v,w});
            adjList[v].push_back({u,w});
        }
        
        priority_queue<pair<int,int>,
                       vector<pair<int,int>>,
                       greater<pair<int,int>>
                       >pq;
                       
        vector<int>visited(V,0);
        
        pq.push({0,0});
        
        int sum=0;
        while(!pq.empty()){
            int node=pq.top().second;
            int weight=pq.top().first;
            pq.pop();
            
            if(visited[node]==1)
                continue;
            
            visited[node]=1;
            sum+=weight;
            
            
            for(auto it:adjList[node]){
                int val=it.first;
                int w=it.second;
                if(visited[val]==0){
                    pq.push({w,val});
                }
            }
        }
        return sum;
        
    }
};
