Given a weighted, undirected, and connected graph with V vertices and E edges, the task is to find the sum of the weights 
of the edges in the Minimum Spanning Tree (MST) of the graph using Kruskal's Algorithm. The graph is represented as an edge 
list edges[][], where edges[i] = [u, v, w] denotes an undirected edge between u and v with weight w.


Example 1:
Input: V = 3, E = 3, edges[][] = [[0, 1, 5], [1, 2, 3], [0, 2, 1]]
Output: 4
Explanation:
The Spanning Tree resulting in a weight of 4 is shown above.

Example 2:
Input: V = 2, E = 1, edges = [[0, 1, 5]]
Output: 5 
Explanation: Only one Spanning Tree is possible which has a weight of 5.
-----------------------------------------------------------------------------------------------------------------------------------------
//kruskal's algo  tc= O(N+E) + O(E logE) + O(E*4Î±*2)   sc=O(N) + O(N) + O(E)
// User function Template for C++


class DisjointSet {
    vector<int> rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

class Solution {
  public:
    int kruskalsMST(int V, vector<vector<int>> &edges) {
        // code here
        vector<pair<int, pair<int, int>>> adj;
        // for (int i = 0; i < V; i++) {
            for (auto it : edges) {
                int u = it[0];
                int v = it[1];
                int w = it[2];

                adj.push_back({w, {u, v}});
            }
        // }
        DisjointSet ds(V);
        sort(adj.begin(), adj.end());
        int mstWt = 0;
        for (auto it : adj) {
            int wt = it.first;
            int u = it.second.first;
            int v = it.second.second;

            if (ds.findUPar(u) != ds.findUPar(v)) {
                mstWt += wt;
                ds.unionBySize(u, v);
            }
        }

        return mstWt;
    }
};
