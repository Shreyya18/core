//try 4th type : to insert before the given value 
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
//create a  new node of doubly linked list(DLL)
struct Node{
    int data;
    Node* next;
    Node* back;
    Node(int data1, Node* next1, Node* back1){
        data=data1;
        next=next1;
        back=back1;
    }
    Node(int data1){
        data=data1;
        next=NULL;
        back=NULL;
    }
};
//convert an array to DLL 
Node* convertArraytoDLL(vector<int> &arr){
    Node* head=new Node(arr[0]);
    Node* mover=head;
    for(int i=1;i<arr.size();i++){
        Node* temp=new Node(arr[i]);
        mover->next=temp;
        temp->back=mover;
        mover=mover->next;
    }
    return head;
}
//traverse the entire DLL
void traverseDLL(Node* head){
    Node* temp=head;
    while(temp!=NULL){
        cout<<temp->data<<" ";
        temp=temp->next;
    }
}
//insert at the front of DLL
Node* insertFront(Node* head, int val){
    Node* temp=new Node(val);
    temp->next=head;
    head->back=temp;
    head=temp;
return head;
}

//insert at the edn of DLL
Node* insertEnd(Node* head, int val){
    Node* temp=new Node(val);
    Node* mover=head;
    while(mover->next!=NULL){
        mover=mover->next;
    }
    mover->next=temp;
    temp->back=mover;
return head;
}

//insert before the give position
Node* insertAtPos(Node* head, int pos, int val){
    Node* temp=new Node(val);
    Node* mover=head;
    int count=0;
    while(mover!=NULL){
        count++;
        if(count==pos)
            break;
        mover=mover->next;
    }
    Node* prev=mover->back;
    if(prev==NULL)
        return insertFront(head,val);
    else{
        prev->next=temp;
        mover->back=temp;
        temp->back=prev;
        temp->next=mover;
    }
    return head;
}
int main() {
//   Node* head=new Node(3);
    // cout<<head->val;
    vector<int> arr={1,2,3,1};
    Node* head=convertArraytoDLL(arr);
    head=insertFront(head, 7);
    head=insertEnd(head,8);
    head=insertAtPos(head, 3,4);
    traverseDLL(head);
    return 0;
}
