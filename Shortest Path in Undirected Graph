You are given an undirected graph with V vertices numbered from 0 to V-1 and E edges, represented as a 2D array edges[][], 
where each element edges[i] = [u, v] represents an undirected edge between vertices u and v.
Your task is to find the shortest path distance from a given source vertex src to all other vertices in the graph.
If a vertex is not reachable from the source, return -1 for that vertex.

Note: All edges have unit weight (1).

Example 1:
Input: V = 9, E = 10, 
edges[][] = [[0, 1], [0, 3], [1, 2], [3, 4], [4, 5], [2, 6], [5, 6], [6, 7], [6, 8], [7, 8]], src = 0
Output: [0, 1, 2, 1, 2, 3, 3, 4, 4]

Example 2:
Input: V = 4, E = 3,
edges[][]= [[0, 3], [1, 3]], src = 3
Output: [1, 1, -1, 0]
------------------------------------------------------------------------------------------------------------------------------------------
//tc=O(V+E) sc=O(V+E)
class Solution {
  public:
    vector<int> shortestPath(int V, vector<vector<int>> &edges, int src) {
        // code here
        vector<vector<int>>adjList(V);
        queue<pair<int,int>>q;
        vector<int>dist(V,-1);
        vector<int>visited(V,0);
        for(auto it:edges){
            adjList[it[0]].push_back(it[1]);
            adjList[it[1]].push_back(it[0]);
        }
        
        q.push({src,0});
        visited[src]=1;
        
        while(!q.empty()){
            int val=q.front().first;
            int distance=q.front().second;
            dist[val]=distance;
            q.pop();
            
            for(auto it:adjList[val]){
                if(!visited[it]){
                    q.push({it, distance+1});
                    visited[it]=1;
                }
            }
        }
        return dist;
    }
};
----------------------------------------------------------------------------------------------------------------------------
//without using visited array. use dist array itself . if dist[i]==-1 that means yet to find the distance.
class Solution {
  public:
    vector<int> shortestPath(int V, vector<vector<int>> &edges, int src) {
        // code here
        vector<vector<int>>adjList(V);
        queue<pair<int,int>>q;
        vector<int>dist(V,-1);

        for(auto it:edges){
            adjList[it[0]].push_back(it[1]);
            adjList[it[1]].push_back(it[0]);
        }
        
        q.push({src,0});
        dist[src]=0;

        while(!q.empty()){
            int val=q.front().first;
            int distance=q.front().second;
            q.pop();
            
            for(auto it:adjList[val]){
                if(dist[it]==-1){
                    q.push({it, distance+1});
                    dist[it]=distance+1;
                }
            }
        }
        return dist;
    }
};
