Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Example 1:
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Example 2:
Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
---------------------------------------------------------------------------------------------------------------------------------------------------
//brute   tc=O(n^2)  sc=O(1)
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
         int n=nums.size();
    int maxCount=0;
    for(int i=0;i<n;i++){
        int zeros=0, count=0;
        for(int j=i;j<n;j++){
            if(nums[j]==1){
                count++;
            }
            if(nums[j]==0){
                zeros++;
                count++;
            }
            if(zeros>k)
                break;

            maxCount=max(maxCount,count);
        }

    }
    return maxCount;
  }
};
------------------------------------------------------------------------------------------
//optimal using sliding window. tc=O(n) sc-O(1)
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int l=0, zero=0;
    int maxCount=0;
    for(int r=0;r<nums.size();r++){
        if(nums[r]==0)
            zero++;

        while(zero>k){
            if(nums[l]==0)
                zero--;
            l++;
        }

        maxCount=max(maxCount,r-l+1);
    }
    return maxCount;
    }
};
